This report was nicely formatted, since each optimization attempt was numbered in each section. The reasonings and explanations for each method were clearly stated, especially for the multi-level blocking. Compared to us, this report has very clear cut results makes it easy to decide which optimizations to use in the second stage. For example, with different block sizes, we could not determine well which block sizes performed better than others. On your graphs however, it was clear that a block size of 64 performed best. From here on, it’s a matter of combining the best options in the first three techniques.

For the sake of completedness, it would be beneficial to include the compilers / compiler flags tested. Looking at some other groups (group 6), it seems that there are some obscure compiler flags and annotations that could be used. In addition from our own tests, we found interesting performance results using -O1 over -O3 on certain optimization methods (perhaps just a fluke?).

One thing we would suggest trying is loop order (specifically jki, but test them all to be sure) and copy optimization (with blocking). Both gave our group significant performance increases. Although they are similar to transposing, there are a few slight differences in how you can combine them with other optimization methods. Copy optimization would also be related to the multi-level blocking in #5.
